{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  getRouteRegex: null,\n  getNamedRouteRegex: null,\n  getNamedMiddlewareRegex: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  getRouteRegex: function () {\n    return getRouteRegex;\n  },\n  getNamedRouteRegex: function () {\n    return getNamedRouteRegex;\n  },\n  getNamedMiddlewareRegex: function () {\n    return getNamedMiddlewareRegex;\n  }\n});\nconst _escaperegexp = require(\"../../escape-regexp\");\nconst _removetrailingslash = require(\"./remove-trailing-slash\");\nconst NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n */\nfunction parseParameter(param) {\n  const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n  const repeat = param.startsWith(\"...\");\n  if (repeat) {\n    param = param.slice(3);\n  }\n  return {\n    key: param,\n    repeat,\n    optional\n  };\n}\nfunction getParametrizedRoute(route) {\n  const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n  const groups = {};\n  let groupIndex = 1;\n  return {\n    parameterizedRoute: segments.map(segment => {\n      if (segment.startsWith(\"[\") && segment.endsWith(\"]\")) {\n        const {\n          key,\n          optional,\n          repeat\n        } = parseParameter(segment.slice(1, -1));\n        groups[key] = {\n          pos: groupIndex++,\n          repeat,\n          optional\n        };\n        return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n      } else {\n        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n      }\n    }).join(\"\"),\n    groups\n  };\n}\nfunction getRouteRegex(normalizedRoute) {\n  const {\n    parameterizedRoute,\n    groups\n  } = getParametrizedRoute(normalizedRoute);\n  return {\n    re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n    groups: groups\n  };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */\nfunction buildGetSafeRouteKey() {\n  let routeKeyCharCode = 97;\n  let routeKeyCharLength = 1;\n  return () => {\n    let routeKey = \"\";\n    for (let i = 0; i < routeKeyCharLength; i++) {\n      routeKey += String.fromCharCode(routeKeyCharCode);\n      routeKeyCharCode++;\n      if (routeKeyCharCode > 122) {\n        routeKeyCharLength++;\n        routeKeyCharCode = 97;\n      }\n    }\n    return routeKey;\n  };\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n  const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n  const getSafeRouteKey = buildGetSafeRouteKey();\n  const routeKeys = {};\n  return {\n    namedParameterizedRoute: segments.map(segment => {\n      if (segment.startsWith(\"[\") && segment.endsWith(\"]\")) {\n        const {\n          key,\n          optional,\n          repeat\n        } = parseParameter(segment.slice(1, -1));\n        // replace any non-word characters since they can break\n        // the named regex\n        let cleanedKey = key.replace(/\\W/g, \"\");\n        if (prefixRouteKeys) {\n          cleanedKey = \"\" + NEXT_QUERY_PARAM_PREFIX + cleanedKey;\n        }\n        let invalidKey = false;\n        // check if the key is still invalid and fallback to using a known\n        // safe key\n        if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n          invalidKey = true;\n        }\n        if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n          invalidKey = true;\n        }\n        if (invalidKey) {\n          cleanedKey = getSafeRouteKey();\n        }\n        if (prefixRouteKeys) {\n          routeKeys[cleanedKey] = \"\" + NEXT_QUERY_PARAM_PREFIX + key;\n        } else {\n          routeKeys[cleanedKey] = \"\" + key;\n        }\n        return repeat ? optional ? \"(?:/(?<\" + cleanedKey + \">.+?))?\" : \"/(?<\" + cleanedKey + \">.+?)\" : \"/(?<\" + cleanedKey + \">[^/]+?)\";\n      } else {\n        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n      }\n    }).join(\"\"),\n    routeKeys\n  };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n  const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n  return {\n    ...getRouteRegex(normalizedRoute),\n    namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n    routeKeys: result.routeKeys\n  };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n  const {\n    parameterizedRoute\n  } = getParametrizedRoute(normalizedRoute);\n  const {\n    catchAll = true\n  } = options;\n  if (parameterizedRoute === \"/\") {\n    let catchAllRegex = catchAll ? \".*\" : \"\";\n    return {\n      namedRegex: \"^/\" + catchAllRegex + \"$\"\n    };\n  }\n  const {\n    namedParameterizedRoute\n  } = getNamedParametrizedRoute(normalizedRoute, false);\n  let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n  return {\n    namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n  };\n}","map":{"version":3,"names":["getRouteRegex","getNamedRouteRegex","getNamedMiddlewareRegex","NEXT_QUERY_PARAM_PREFIX","parseParameter","param","optional","startsWith","endsWith","slice","repeat","key","getParametrizedRoute","route","segments","_removetrailingslash","removeTrailingSlash","split","groups","groupIndex","parameterizedRoute","map","segment","pos","_escaperegexp","escapeStringRegexp","join","normalizedRoute","re","RegExp","buildGetSafeRouteKey","routeKeyCharCode","routeKeyCharLength","routeKey","i","String","fromCharCode","getNamedParametrizedRoute","prefixRouteKeys","getSafeRouteKey","routeKeys","namedParameterizedRoute","cleanedKey","replace","invalidKey","length","isNaN","parseInt","prefixRouteKey","result","namedRegex","options","catchAll","catchAllRegex","catchAllGroupedRegex"],"sources":["../../../../../src/shared/lib/router/utils/route-regex.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}